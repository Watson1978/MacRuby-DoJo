<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: MacRuby | MacRuby DoJo (道場)]]></title>
  <link href="http://watson1978.github.com/MacRuby-DoJo/blog/categories/macruby/atom.xml" rel="self"/>
  <link href="http://watson1978.github.com/MacRuby-DoJo/"/>
  <updated>2012-04-14T14:12:57+09:00</updated>
  <id>http://watson1978.github.com/MacRuby-DoJo/</id>
  <author>
    <name><![CDATA[Watson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Sandbox Class]]></title>
    <link href="http://watson1978.github.com/MacRuby-DoJo/blog/2012/04/14/sandbox-class/"/>
    <updated>2012-04-14T14:00:00+09:00</updated>
    <id>http://watson1978.github.com/MacRuby-DoJo/blog/2012/04/14/sandbox-class</id>
    <content type="html"><![CDATA[<p>MacRuby has the Sandbox class which restricts the access to network. Sandbox class is implemented using the <a href="https://developer.apple.com/library/mac/#documentation/Darwin/Reference/ManPages/man7/sandbox.7.html">sandbox(7)</a> in MacRuby.</p>

<p>You can restrict easily your application to access the network by <code>Sandbox.no_network.apply!</code>. Ruby methods and Cocoa APIs both are restricted by the Sandbox.</p>

<p>```ruby</p>

<blockquote><blockquote><p>framework 'Cocoa'
require 'socket'
Sandbox.no_network.apply!
Socket.gethostbyaddr("apple.com")
SocketError: host not found</p>

<p>NSHost.hostWithName("apple.com")
=> <NSHost 0x40121eb80> (null) ((
) (
))
```</p></blockquote></blockquote>

<p>The Sandbox is a good companion to the Ruby standard $SAFE functionality, you may use the Sandbox and $SAFE at the same time.</p>

<p>The Sandbox will be able to restrict your application,</p>

<ul>
<li>TCP/IP networking is prohibited.</li>
<li>All sockets-based networking is prohibited.</li>
<li>File system writes are prohibited.</li>
<li>File system writes are restricted to temporary folders.</li>
<li>All operating system services are prohibited.</li>
</ul>


<p>As notes,</p>

<ul>
<li>Restriction is not able to change after applying.</li>
<li>Restricts with respect to each process.</li>
</ul>


<h2>Methods in Sandbox Class</h2>

<h3>Sandbox.no_internet</h3>

<p>Restricts TCP/IP networking in current process.</p>

<ul>
<li>no_internet -> Sandbox

<ul>
<li>[RETURN]

<ul>
<li>Returns a Sandbox instance.</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>Sandbox.no_network</h3>

<p>Restricts all sockets-based networking in current process.</p>

<ul>
<li>no_network -> Sandbox

<ul>
<li>[RETURN]

<ul>
<li>Returns a Sandbox instance.</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>Sandbox.no_writes</h3>

<p>Restricts to write in current process.</p>

<ul>
<li>no_writes -> Sandbox

<ul>
<li>[RETURN]

<ul>
<li>Returns a Sandbox instance.</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>Sandbox.temporary_writes</h3>

<p>Restricts to write outside temporay folders in current process.</p>

<ul>
<li>temporary_writes -> Sandbox

<ul>
<li>[RETURN]

<ul>
<li>Returns a Sandbox instance.</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>Sandbox.pure_computation</h3>

<p>Restrictsn all operating system services in current process.</p>

<ul>
<li>pure_computation -> Sandbox

<ul>
<li>[RETURN]

<ul>
<li>Returns a Sandbox instance.</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>Sandbox#apply!</h3>

<p>Applies the restriction.</p>

<ul>
<li>apply!</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Boxed Class]]></title>
    <link href="http://watson1978.github.com/MacRuby-DoJo/blog/2012/04/02/boxed-class/"/>
    <updated>2012-04-02T14:00:00+09:00</updated>
    <id>http://watson1978.github.com/MacRuby-DoJo/blog/2012/04/02/boxed-class</id>
    <content type="html"><![CDATA[<p>Boxed class is used to retrieve a structure information that is defined in Cocoa. All structures allow to retrieve an information by Boxed Class.</p>

<h2>Methods in Boxed Class</h2>

<h3>Boxed.type</h3>

<p>Returns a structure type information.</p>

<ul>
<li>type -> String

<ul>
<li>[RETURN]

<ul>
<li>Returns a structure type information.</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>```ruby</p>

<blockquote><blockquote><p>framework 'Cocoa'
NSRect.type
=> "{CGRect={CGPoint=dd}{CGSize=dd}}"
```</p></blockquote></blockquote>

<h3>Boxed.opaque?</h3>

<p>Returns whether structure is opaque.</p>

<ul>
<li>opaque? -> bool

<ul>
<li>[RETURN]

<ul>
<li>Returns a true if structure is opaque. Otherwise, returns a false.</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>```ruby</p>

<blockquote><blockquote><p>framework 'Cocoa'
NSRect.opaque?
=> false
NSModalSession.opaque?
=> true</p>

<p>```</p></blockquote></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pointer Class]]></title>
    <link href="http://watson1978.github.com/MacRuby-DoJo/blog/2012/04/02/pointer-class/"/>
    <updated>2012-04-02T10:00:00+09:00</updated>
    <id>http://watson1978.github.com/MacRuby-DoJo/blog/2012/04/02/pointer-class</id>
    <content type="html"><![CDATA[<p>If you use the Cocoa APIs, you might have to pass a pointer variable into argument of API. Some cases, you might need a variable such as <code>NSError* error;</code>.</p>

<p>To create a pointer instance as <code>NSError* error;</code>, you can write a program as following.</p>

<p><code>ruby
error = Pointer.new('@')
</code></p>

<p>You can create other Pointer instance if you pass a pointer type into <code>Pointer.new</code>. You can find the other pointer type in <a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">Type Encodings</a>.</p>

<p>To create a Pointer instance such as <code>char* name[5];</code>, specify a size in the second argument.</p>

<p><code>ruby
name = Pointer.new('c', 5)
name[0] = 'a'
name[1] = 'b'
name[2] = 'c'
name[3] = 'd'
name[4] = 'e'
</code></p>

<p>To create a Pointer instance of structure such as <code>NSRect *rect[2];</code>, you may write a program as following.</p>

<p><code>ruby
rect = Pointer.new("{CGRect={CGPoint=dd}{CGSize=dd}}", 2)
</code></p>

<p>Or,</p>

<p><code>ruby
rect = Pointer.new(NSRect.type, 2)
</code></p>

<h2>Alias of Pointer Types</h2>

<p>You may think difficult the pointer types such as <code>'@'</code>. MacRuby has the alias of pointer types.</p>

<p><code>ruby
error = Pointer.new(:object)  # alias of '@'
</code></p>

<table class="table">
<tr><th>Meaning</th><th>Pointer Types</th><th>Alias</th>
<tr><td>char</td><td>Pointer.new('c')</td><td>Pointer.new(:char)</td></tr>
<tr><td>unsigned char</td><td>Pointer.new('C')</td><td>Pointer.new(:uchar)</td></tr>
<tr><td>short</td><td>Pointer.new('s')</td><td>Pointer.new(:short)</td></tr>
<tr><td>unsigned short</td><td>Pointer.new('S')</td><td>Pointer.new(:ushort)</td></tr>
<tr><td>int</td><td>Pointer.new('i')</td><td>Pointer.new(:int)</td></tr>
<tr><td>unsigned int</td><td>Pointer.new('I')</td><td>Pointer.new(:uint)</td></tr>
<tr><td>long</td><td>Pointer.new('l')</td><td>Pointer.new(:long)</td></tr>
<tr><td>unsigned long</td><td>Pointer.new('L')</td><td>Pointer.new(:ulong)</td></tr>
<tr><td>long long</td><td>Pointer.new('q')</td><td>Pointer.new(:long_long)</td></tr>
<tr><td>unsigned long long</td><td>Pointer.new('Q')</td><td>Pointer.new(:ulong_long)</td></tr>
<tr><td>float</td><td>Pointer.new('f')</td><td>Pointer.new(:float)</td></tr>
<tr><td>double</td><td>Pointer.new('d')</td><td>Pointer.new(:double)</td></tr>
<tr><td>character string (char *)</td><td>Pointer.new('*')</td><td>Pointer.new(:string)</td></tr>
<tr><td>pointer</td><td>Pointer.new('^')</td><td>Pointer.new(:pointer)</td></tr>
<tr><td>object</td><td>Pointer.new('@')</td><td>Pointer.new(:object)<br>Pointer.new(:id)</td></tr>
<tr><td>class object (Class)</td><td>Pointer.new('#')</td><td>Pointer.new(:class)</td></tr>
<tr><td>boolean</td><td>Pointer.new('B')</td><td>Pointer.new(:boolean)<br>Pointer.new(:bool)</td></tr>
<tr><td>method selector (SEL)</td><td>Pointer.new(':')</td><td>Pointer.new(:selector)<br>Pointer.new(:sel)</td></tr>
</table>


<h2>Methods in Pointer Class</h2>

<h3>Pointer.new</h3>

<p>Returns a new Pointer instance.</p>

<ul>
<li>new(type, size = 1) -> Pointer

<ul>
<li>[PARAM] type:

<ul>
<li>Specifies a pointer type.</li>
</ul>
</li>
<li>[PARAM] size:

<ul>
<li>Specifies a size to allocate an array.</li>
</ul>
</li>
<li>[RETURN]

<ul>
<li>Returns a new Pointer instance.</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>Pointer.new_with_type</h3>

<p>This method is alias of <code>Pointer.new</code>.</p>

<h3>Pointer.magic_cookie</h3>

<p>Returns a new Pointer instance which cast an immediate value to (void *).</p>

<ul>
<li>magic_cookie(val) -> Pointer

<ul>
<li>[PARAM] val:

<ul>
<li>Passes an immediate value to cast.</li>
</ul>
</li>
<li>[RETURN]

<ul>
<li>Returns a new Pointer instance.</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>Pointer#type</h3>

<p>Returns a pointer type.</p>

<ul>
<li>type -> String

<ul>
<li>[RETURN]

<ul>
<li>Returns a string as pointer type.</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>```ruby</p>

<blockquote><blockquote><p>framework 'Cocoa'
pointer = Pointer.new(NSRect.type)
pointer.type
=> "{CGRect={CGPoint=dd}{CGSize=dd}}"
```</p></blockquote></blockquote>

<h3>Pointer#cast!</h3>

<p>Changes a pointer type.</p>

<ul>
<li>cast!(type) -> self

<ul>
<li>[PARAM] type:

<ul>
<li>Specifies a new point type.</li>
</ul>
</li>
<li>[RETURN]

<ul>
<li>Returns a self which pointer type was changed.</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>```ruby</p>

<blockquote><blockquote><p>pointer = Pointer.new('i')
pointer.type
=> "i"
pointer.cast!('I')
pointer.type
=> "I"
```</p></blockquote></blockquote>

<h3>Pointer#[]</h3>

<p>Get a value at nth position.</p>

<ul>
<li>self[nth]

<ul>
<li>[PARAM] nth:

<ul>
<li>Specifies a position to get a value.</li>
</ul>
</li>
<li>[RETURN]

<ul>
<li>Returns a value.</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>Pointer#[]=</h3>

<p>Set a value into nth position.</p>

<ul>
<li>self[nth] = val

<ul>
<li>[PARAM] nth:

<ul>
<li>Specifies a position to set a value.</li>
</ul>
</li>
<li>[PARAM] val:

<ul>
<li>Passes a value to set.</li>
</ul>
</li>
<li>[RETURN]

<ul>
<li>Returns a <code>val</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>Pointer#value</h3>

<p>Get a value at 0 position.</p>

<ul>
<li>value

<ul>
<li>[RETURN]

<ul>
<li>Returns a value at 0 position.</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>```ruby
pointer = Pointer.new('c')
pointer[0] = 42</p>

<p>pointer[0]    # => 42
pointer.value # => 42
```</p>

<h3>Pointer#assign</h3>

<p>Set a value into 0 position.</p>

<ul>
<li>assign(val)

<ul>
<li>[PARAM] val:

<ul>
<li>Specifies a position to set a value.</li>
</ul>
</li>
<li>[RETURN]

<ul>
<li>Returns a <code>val</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>Pointer#+</h3>

<p>Returns a new Pointer instance from the specified offset.</p>

<ul>
<li>self + offset -> Pointer

<ul>
<li>[PARAM] offset:

<ul>
<li>Specifies an offset.</li>
</ul>
</li>
<li>[RETURN]

<ul>
<li>Returns a new Pointer instance</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>```ruby
name = Pointer.new('c', 5)
name[0] = 10
name[1] = 11
name[2] = 12
name[3] = 13
name[4] = 14</p>

<p>tmp = name + 3
2.times do |i|
  p tmp[i] # => 13, 14
end
```</p>

<h3>Pointer#-</h3>

<p>Returns a new Pointer instance from the specified offset.</p>

<ul>
<li>self - offset -> Pointer

<ul>
<li>[PARAM] offset:

<ul>
<li>Specifies an offset.</li>
</ul>
</li>
<li>[RETURN]

<ul>
<li>Returns a new Pointer instance</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>Pointer#to_object</h3>

<p>TBD</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Original Methods in MacRuby]]></title>
    <link href="http://watson1978.github.com/MacRuby-DoJo/blog/2012/03/31/original-methods/"/>
    <updated>2012-03-31T16:00:00+09:00</updated>
    <id>http://watson1978.github.com/MacRuby-DoJo/blog/2012/03/31/original-methods</id>
    <content type="html"><![CDATA[<p>MacRuby has some original methods. They does not exist in CRuby's methods and Cocoa APIs. This content describes those methods.</p>

<h2>Original Methods</h2>

<h3>String#transform</h3>

<p>Transforms the string to uppercase/lowercase or another language characters.
This method is implemented with <a href="http://site.icu-project.org/">ICU</a>  <a href="http://userguide.icu-project.org/transforms/general">Transforms</a>.</p>

<ul>
<li>transform(pattern) -> String

<ul>
<li>[PARAM] pattern:

<ul>
<li>Specifies transliteration identifier.</li>
</ul>
</li>
<li>[RETURN]

<ul>
<li>Returns the transformed string.</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>```ruby</p>

<blockquote><blockquote><p>"hello".transform("Upper")
=> "HELLO"
"HELLO".transform("Lower")
=> "hello"
"hello".transform("Hiragana")
=> "へっろ"
"hello".transform("Greek")
=> "ἑλλο"
```</p></blockquote></blockquote>

<h3>String#pointer</h3>

<p>Returns a Pointer object converted from String. Returned object corresponds to a variable of <code>unsigned char *</code>.</p>

<p>Cocoa APIs has some methods which accepts the pointer variable.
<code>String#pointer</code> may be used for these methods.</p>

<ul>
<li>pinter -> Pointer

<ul>
<li>[RETURN]

<ul>
<li>Returns a Pointer object converted from String.</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>```ruby</p>

<blockquote><blockquote><p>pointer = "foo".pointer
=> #&lt;Pointer:0x4007ac580>
data = NSData.dataWithBytes(pointer, length: "foo".length)
=> <666f6f>
data.to_str
=> "foo"
```</p></blockquote></blockquote>

<h3>String#to_data</h3>

<p>Returns an <a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Reference/Foundation/Classes/NSData_Class/Reference/Reference.html">NSData</a> object which is converted from String.</p>

<ul>
<li>to_data -> NSData

<ul>
<li>[RETURN]

<ul>
<li>Returns a NSData object.</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>```ruby</p>

<blockquote><blockquote><p>"foo".to_data
=> <666f6f>
"foo".to_data.class
=> __NSCFData
```</p></blockquote></blockquote>

<h3>NSData#to_str</h3>

<p>Returns a String object which is converted from NSData.</p>

<ul>
<li>to_str -> String

<ul>
<li>[RETURN]

<ul>
<li>Returns a String object</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>```ruby</p>

<blockquote><blockquote><p>data = "foo".to_data
=> <666f6f>
data.to_str
=> "foo"
```</p></blockquote></blockquote>

<h3>Kernel.framework</h3>

<p>Loads a framework.</p>

<ul>
<li>framework -> bool

<ul>
<li>[RETURN]

<ul>
<li>Returns a true if loaded a framework. Otherwise, returns a false.</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>```ruby</p>

<blockquote><blockquote><p>framework 'Foundation'
=> true
```</p></blockquote></blockquote>

<h3>Kernel.load_bridge_support_file</h3>

<p>Loads a Bridge Support file.</p>

<ul>
<li>load_bridge_support_file(filename) -> self</li>
</ul>


<p>```ruby</p>

<blockquote><blockquote><p>load_bridge_support_file("Foo.bridgesupport")
=> main
```</p></blockquote></blockquote>

<h3>Kernel.load_plist</h3>

<p>Returns an object which is converted from string of plist format.</p>

<ul>
<li>load_plist(string) -> Object

<ul>
<li>[PARAM] string:

<ul>
<li>Passes a string of plist format.</li>
</ul>
</li>
<li>[RETURN]

<ul>
<li>Returns an object.</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>```ruby</p>

<blockquote><blockquote><p>data = File.read('StopWatch-Info.plist')
load_plist(data)
=> {"CFBundleName"=>"${PRODUCT_NAME}", "CFBundleIdentifier"=>"Watson.${PRODUCT_NAME:rfc1034identifier}", "CFBundleInfoDictionaryVersion"=>"6.0", "CFBundleVersion"=>"1", "CFBundleExecutable"=>"${EXECUTABLE_NAME}", "NSPrincipalClass"=>"NSApplication", "CFBundlePackageType"=>"APPL", "CFBundleIconFile"=>"MacRuby.icns", "CFBundleSignature"=>"????", "NSMainNibFile"=>"MainMenu", "LSMinimumSystemVersion"=>"${MACOSX_DEPLOYMENT_TARGET}", "CFBundleDevelopmentRegion"=>"en", "CFBundleShortVersionString"=>"1.0"}</p>

<p>data = "foo".to_plist
load_plist(data)
=> "foo"
```</p></blockquote></blockquote>

<h3>Object#to_plist</h3>

<p>Returns a string of plist format which is converted from Object.</p>

<ul>
<li>to_plist -> String

<ul>
<li>[RETURN]

<ul>
<li>Returns a string of plist format.</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>```ruby</p>

<blockquote><blockquote><p>"foo".to_plist
=> "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<string>foo</string>\n</plist>\n"
{"foo" => 42}.to_plist
=> "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>foo</key>\n\t<integer>42</integer>\n</dict>\n</plist>\n"
["foo", "bar"].to_plist
=> "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<array>\n\t<string>foo</string>\n\t<string>bar</string>\n</array>\n</plist>\n"
```</p></blockquote></blockquote>

<h3>Object#methods</h3>

<p>Returns a methods list. CRuby also has <code>Object#methods</code>, <code>objc_methods</code> argument is added to MacRuby's method.</p>

<ul>
<li>methods(include_inherited = true, objc_methods = false) -> [Symbol]

<ul>
<li>[PARAM] include_inherited:

<ul>
<li>If passes a true, looks up a recursively.</li>
</ul>
</li>
<li>[PARAM] objc_methods:

<ul>
<li>If passes a true, returns the Ruby's methods and Cocoa APIs.</li>
</ul>
</li>
<li>[RETURN]

<ul>
<li>Returns a method list.</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>```ruby</p>

<blockquote><p>"foo".methods(true, true)
=> [:encode!, :"replaceCharactersInRange:withString:", :"getCharacters:range:", :characterAtIndex, :length, :transform, :crypt, :rpartition, :partition, :sum, :tr_s!, :tr_s, :tr!, :tr, :squeeze!, :squeeze, :delete!, :delete, :count, :reverse!, :reverse, :upto, :next!, :next, :succ!, :succ, :each_codepoint, :codepoints, :each_byte, :bytes, :each_char, :chars, :each_line, :lines, :rstrip!, :lstrip!, :strip!, :rstrip, :lstrip, :strip, :center, :rjust, :ljust, :capitalize!, :capitalize, :swapcase!, :swapcase, :upcase!, :upcase, :downcase!, :downcase, :gsub!, :gsub, :sub!, :sub, :chop!, :chop, :chomp!, :chomp, :to_f, :chr, :ord, :oct, :hex, :to_i, :split, :scan, :=~, :match, :dump, :inspect, :intern, :to_sym, :to_str, :to_s, :end_with?, :start_with?, :include?, :eql?, :casecmp, :&lt;=>, :==, :concat, :&lt;&lt;, :%, :*, :+, :rindex, :index, :insert, :slice!, :slice, :[]=, :[], :ascii_only?, :valid_encoding?, :force_encoding, :pointer, :to_data, :setbyte, :getbyte, :bytesize, :empty?, :size, :encoding, :clear, :replace, :dup, :"performSelector:withObject:withObject:", :"performSelector:withObject:", :performSelector, :conformsToProtocol, :dd_appendSpaces, :"replaceOccurrencesOfString:withString:options:range:", :initWithCapacity,  ---- snip ----
```</p></blockquote>

<h3>Range#relative_to</h3>

<p>Returns a new Range instance which has negative values in <code>rng</code> expanded relative to <code>max</code>.</p>

<ul>
<li>relative_to(max) -> Range

<ul>
<li>[PARAM] max:

<ul>
<li>Specifies a max of Range.</li>
</ul>
</li>
<li>[RETURN]

<ul>
<li>Returns a new Range instance.</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>```ruby</p>

<blockquote><blockquote><p>(1..10).relative_to(5)
=> 1..5
(-2..-1).relative_to(5)
=> 3..4
```</p></blockquote></blockquote>

<h3>BasicSocket#sendfile</h3>

<p>Sends a file with socket. This method is implemented with <a href="http://developer.apple.com/library/ios/#DOCUMENTATION/System/Conceptual/ManPages_iPhoneOS/man2/sendfile.2.html">sendfile(2)</a>.</p>

<ul>
<li>sendfile(file, offset, length) -> Integer

<ul>
<li>[PARAM] file:

<ul>
<li>Specifies a file path or readable IO object.</li>
</ul>
</li>
<li>[PARAM] offset:

<ul>
<li>Specifies a offset as start position.</li>
</ul>
</li>
<li>[PARAM] length:

<ul>
<li>Specifies a length to send.</li>
</ul>
</li>
<li>[RETURN]

<ul>
<li>Returns a sent length.</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>```ruby
require 'socket'</p>

<p>port = 5000
socket = TCPSocket.open('localhost', port)</p>

<p>path = 'sample.txt'
socket.sendfile(path, 0, 128)
```</p>

<h3>Fixnum#popcnt</h3>

<p>Returns the number of 1 bits set in the internal representation of Fixnum.</p>

<ul>
<li>popcnt -> Fixnum</li>
</ul>


<p>```ruby</p>

<blockquote><blockquote><p>13.to_s(2)
=> "1101"
13.popcnt
=> 3
255.to_s(2)
=> "11111111"
255.popcnt
=> 8
```</p></blockquote></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Original Constants in MacRuby]]></title>
    <link href="http://watson1978.github.com/MacRuby-DoJo/blog/2012/03/31/original-constants/"/>
    <updated>2012-03-31T16:00:00+09:00</updated>
    <id>http://watson1978.github.com/MacRuby-DoJo/blog/2012/03/31/original-constants</id>
    <content type="html"><![CDATA[<p>This content describes the constants that have been added in MacRuby.</p>

<h2>Original Constants</h2>

<h3>Kernel::RUBY_ARCH</h3>

<p>CPU name of the architecture which MacRuby is ran.</p>

<p>```ruby</p>

<blockquote><blockquote><p>Kernel::RUBY_ARCH
=> "x86_64"
```</p></blockquote></blockquote>

<h3>Kernel::MACRUBY_VERSION</h3>

<p>MacRuby version.</p>

<p>```ruby</p>

<blockquote><blockquote><p>Kernel::MACRUBY_VERSION
=> "0.12"
```</p></blockquote></blockquote>

<p>Following method may check whether running your program on MacRuby.
```ruby
def is_macruby?
  begin</p>

<pre><code>MACRUBY_VERSION
return true
</code></pre>

<p>  rescue</p>

<pre><code>return false
</code></pre>

<p>  end
end
```</p>

<h3>Kernel::MACRUBY_REVISION</h3>

<p>Git SHA1 Hash which indicates a last commit. (Older MacRuby shows a revision number of SVN)</p>

<p>```ruby</p>

<blockquote><blockquote><p>Kernel::MACRUBY_REVISION
=> "git commit e35df75944e7a13d16f019e2ed1e4ce2406b06af"
```</p></blockquote></blockquote>

<h3>Dir::NS_TMPDIR</h3>

<p>Path of temporary directory.</p>

<p>```ruby</p>

<blockquote><blockquote><p>Dir::NS_TMPDIR
=> "/var/folders/1z/ff7x15cj7vb24rl38ty0y52w0000gn/T/"
```</p></blockquote></blockquote>
]]></content>
  </entry>
  
</feed>
